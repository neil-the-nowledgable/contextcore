import json
import re
import urllib.request
import urllib.parse
from typing import List, Optional, Tuple
from datetime import datetime, timedelta

from contextcore.learning.models import Lesson, LessonQuery, LessonCategory

__all__ = ['LessonRetriever']


class LessonRetriever:
    """Retrieves lessons from Tempo using TraceQL queries for agent work sessions."""
    
    def __init__(self, tempo_url: str = "http://localhost:3200"):
        """Initialize the retriever with Tempo URL.
        
        Args:
            tempo_url: Base URL for Tempo API (trailing slashes will be stripped)
        """
        self.tempo_url = tempo_url.rstrip('/')

    def retrieve(self, query: LessonQuery) -> List[Lesson]:
        """Execute a lesson query against Tempo.
        
        Args:
            query: LessonQuery object containing search parameters
            
        Returns:
            List of Lesson objects sorted by effectiveness_score descending
        """
        try:
            # Build TraceQL query from LessonQuery
            traceql_query = self._build_traceql(query)
            
            # Execute query against Tempo
            raw_results = self._query_tempo(traceql_query, query.time_range or "7d")
            
            # Parse and filter results
            lessons = self._parse_results(raw_results)
            
            # Apply confidence filter
            filtered_lessons = [
                lesson for lesson in lessons 
                if lesson.confidence_score >= query.min_confidence
            ]
            
            # Sort by effectiveness_score descending
            filtered_lessons.sort(key=lambda x: x.effectiveness_score, reverse=True)
            
            # Return top max_results
            return filtered_lessons[:query.max_results] if query.max_results else filtered_lessons
            
        except Exception as e:
            # Log error and return empty list for graceful degradation
            print(f"Warning: Failed to retrieve lessons: {e}")
            return []

    def get_lessons_for_file(self, file_path: str, project_id: Optional[str] = None, 
                           category: Optional[LessonCategory] = None) -> List[Lesson]:
        """Get lessons applicable to a specific file.
        
        Args:
            file_path: Path to the file
            project_id: Optional project ID filter
            category: Optional lesson category filter
            
        Returns:
            List of applicable lessons
        """
        query = LessonQuery(
            project_id=project_id,
            category=category,
            applies_to=[file_path]
        )
        return self.retrieve(query)

    def get_lessons_for_task(self, task_type: str, project_id: Optional[str] = None) -> List[Lesson]:
        """Get lessons for a specific task type.
        
        Args:
            task_type: Type of task (testing, debugging, refactoring, implementation, analysis)
            project_id: Optional project ID filter
            
        Returns:
            List of relevant lessons
        """
        # Map task types to categories
        task_category_map = {
            "testing": LessonCategory.TESTING,
            "debugging": LessonCategory.DEBUGGING,
            "refactoring": LessonCategory.REFACTORING,
            "implementation": LessonCategory.IMPLEMENTATION,
            "analysis": LessonCategory.ANALYSIS
        }
        
        category = task_category_map.get(task_type.lower(), LessonCategory.GENERAL)
        query = LessonQuery(project_id=project_id, category=category)
        return self.retrieve(query)

    def get_global_lessons(self, category: Optional[LessonCategory] = None, 
                          min_confidence: float = 0.9) -> List[Lesson]:
        """Get global lessons (not project-specific).
        
        Args:
            category: Optional lesson category filter
            min_confidence: Minimum confidence threshold (default 0.9)
            
        Returns:
            List of global lessons
        """
        query = LessonQuery(
            project_id=None,  # None means global lessons
            category=category,
            min_confidence=min_confidence
        )
        return self.retrieve(query)

    def _build_traceql(self, query: LessonQuery) -> str:
        """Build TraceQL query string from LessonQuery.
        
        Args:
            query: LessonQuery object
            
        Returns:
            TraceQL query string
        """
        conditions = ['span.insight.type = "lesson"']
        
        # Add project condition
        if query.project_id:
            conditions.append(f'resource.project.id = "{query.project_id}"')
        else:
            # Include global lessons when no project specified
            conditions.append('(resource.project.id = "global" || !has(resource.project.id))')
        
        # Add category condition
        if query.category:
            conditions.append(f'span.lesson.category = "{query.category.value}"')
        
        # Add file pattern matching for applies_to
        if query.applies_to:
            file_conditions = []
            for pattern in query.applies_to:
                # Escape special regex characters for literal matching
                escaped_pattern = re.escape(pattern)
                file_conditions.append(f'span.lesson.applies_to =~ ".*{escaped_pattern}.*"')
            
            if file_conditions:
                conditions.append(f'({" || ".join(file_conditions)})')
        
        return "{ " + " && ".join(conditions) + " }"

    def _query_tempo(self, traceql: str, time_range: str) -> List[dict]:
        """Execute TraceQL query against Tempo API.
        
        Args:
            traceql: TraceQL query string
            time_range: Time range string (e.g., "7d", "1h")
            
        Returns:
            List of raw result dictionaries from Tempo
        """
        start_time, end_time = self._parse_time_range(time_range)
        
        # Build query URL with proper encoding
        params = {
            'q': traceql,
            'start': str(start_time),
            'end': str(end_time)
        }
        query_string = urllib.parse.urlencode(params)
        url = f"{self.tempo_url}/api/search?{query_string}"
        
        try:
            request = urllib.request.Request(url)
            with urllib.request.urlopen(request) as response:
                data = json.load(response)
                # Extract traces from response
                return data.get('traces', [])
                
        except urllib.error.URLError as e:
            raise ConnectionError(f"Failed to connect to Tempo at {self.tempo_url}: {e}")
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON response from Tempo: {e}")

    def _parse_results(self, raw_results: List[dict]) -> List[Lesson]:
        """Parse raw Tempo results into Lesson objects.
        
        Args:
            raw_results: List of raw trace dictionaries from Tempo
            
        Returns:
            List of parsed Lesson objects
        """
        lessons = []
        
        for trace in raw_results:
            # Extract spans from each trace
            spans = trace.get('spans', [])
            
            for span in spans:
                try:
                    # Extract lesson attributes from span
                    attributes = span.get('attributes', {})
                    
                    # Parse applies_to as JSON if it's a string
                    applies_to_raw = attributes.get('applies_to', [])
                    if isinstance(applies_to_raw, str):
                        try:
                            applies_to = json.loads(applies_to_raw)
                        except json.JSONDecodeError:
                            applies_to = [applies_to_raw]  # Treat as single item
                    else:
                        applies_to = applies_to_raw if isinstance(applies_to_raw, list) else []
                    
                    # Create Lesson object
                    lesson = Lesson(
                        content=attributes.get('content', ''),
                        context=attributes.get('context', ''),
                        category=LessonCategory(attributes.get('category', 'GENERAL')),
                        applies_to=applies_to,
                        confidence_score=float(attributes.get('confidence_score', 0.0)),
                        effectiveness_score=float(attributes.get('effectiveness_score', 0.0)),
                        project_id=attributes.get('project_id'),
                        timestamp=attributes.get('timestamp')
                    )
                    lessons.append(lesson)
                    
                except (KeyError, ValueError, TypeError) as e:
                    # Skip malformed records but continue processing
                    continue
        
        return lessons

    def _parse_time_range(self, time_range: str) -> Tuple[int, int]:
        """Parse time range string to start/end timestamps.
        
        Args:
            time_range: Time range string (e.g., "1h", "7d", "30d", "1m")
            
        Returns:
            Tuple of (start_timestamp, end_timestamp) as Unix timestamps
        """
        if not time_range:
            time_range = "7d"  # Default to 7 days
        
        current_time = datetime.now()
        end_timestamp = int(current_time.timestamp())
        
        try:
            # Parse the time range format
            if time_range.endswith('h'):
                hours = int(time_range[:-1])
                start_time = current_time - timedelta(hours=hours)
            elif time_range.endswith('d'):
                days = int(time_range[:-1])
                start_time = current_time - timedelta(days=days)
            elif time_range.endswith('m'):
                # 'm' means months (30 days as specified)
                months = int(time_range[:-1])
                start_time = current_time - timedelta(days=months * 30)
            else:
                # Default to 7 days if format not recognized
                start_time = current_time - timedelta(days=7)
                
        except ValueError:
            # Fallback to 7 days if parsing fails
            start_time = current_time - timedelta(days=7)
        
        start_timestamp = int(start_time.timestamp())
        return start_timestamp, end_timestamp
