# Lessons Learned - ContextCore Development

This document captures lessons learned during ContextCore development, organized by date for easy reference and appending.

---

## 2026-01-22: TUI Implementation & startd8 SDK Integration

### Code Extraction from AI-Generated Content

**Problem:** When extracting code from markdown code blocks generated by AI workflows, file markers can appear inside the code blocks rather than outside them.

**Solution:** 
- Use regex patterns that look for file markers (`# === FILE: path ===`) inside code blocks
- Handle both Python (`#`) and CSS (`/* */`) style markers
- Strip markers from extracted code before saving
- Provide fallback extraction for code blocks without markers

**Example Pattern:**
```python
# Pattern: ```python\n# === FILE: path ===\n...code...```
code_block_pattern = r'```(python|css|tcss)\n(.*?)```'
file_marker_pattern = r'(?:#|/\*)\s*===\s*FILE:\s*([^\s=]+(?:\s+[^\s=]+)*)\s*===\s*(?:\*/)?'
```

**Key Takeaway:** Always validate and handle multiple formats when parsing AI-generated content. Don't assume a single consistent format.

---

### Defensive Programming for External SDK Integration

**Problem:** When integrating with external SDKs (like startd8), workflow results may have `None` values for attributes, causing `AttributeError` when accessing nested properties.

**Solution:** Implement defensive checks at every level:
1. Check if result object exists
2. Check if attributes exist before accessing
3. Use `.get()` with defaults for dictionaries
4. Validate types before operations
5. Wrap risky operations in try/except

**Pattern:**
```python
# Bad: Direct access (can fail)
cost = result.metrics.total_cost

# Good: Defensive access
if hasattr(result, 'metrics') and result.metrics:
    try:
        cost = result.metrics.total_cost if hasattr(result.metrics, 'total_cost') else 0
    except (AttributeError, TypeError):
        cost = 0
else:
    cost = 0
```

**Key Takeaway:** When integrating external SDKs, assume nothing about return value structure. Always validate before access.

---

### Error Handling Strategy for Batch Processing

**Problem:** When processing multiple features in a batch, one failure should not stop the entire process.

**Solution:**
- Wrap each feature processing in try/except
- Collect failed results with error messages
- Continue processing remaining features
- Provide summary statistics at the end

**Pattern:**
```python
results = []
for feature in features:
    try:
        result = process_feature(feature)
        results.append(result)
    except Exception as e:
        # Log error but continue
        results.append({
            "success": False,
            "error": str(e),
            # ... other fields with defaults
        })
        continue

# Summary
print(f"Successful: {sum(1 for r in results if r['success'])}")
print(f"Failed: {sum(1 for r in results if not r['success'])}")
```

**Key Takeaway:** Design batch operations to be resilient. One failure shouldn't prevent learning from other successes.

---

### File I/O Error Handling

**Problem:** File operations can fail for many reasons (permissions, disk space, path issues), and failures should be handled gracefully.

**Solution:**
- Wrap each file operation in try/except
- Provide specific error messages
- Continue processing other files even if one fails
- Use safe defaults for missing data

**Pattern:**
```python
try:
    with open(file_path, "w") as f:
        f.write(content)
    print(f"Saved: {file_path}")
except Exception as e:
    print(f"Error saving {file_path}: {e}")
    # Continue with next file
```

**Key Takeaway:** File I/O is inherently risky. Always handle failures gracefully and provide actionable error messages.

---

### Type Validation Before String Operations

**Problem:** Assuming variables are strings can cause `TypeError` when they're `None` or other types.

**Solution:** Validate types before string operations:
```python
# Bad: Assumes string
text = result["final_implementation"]
files = extract_code_blocks(text)

# Good: Validates type
final_implementation = result.get("final_implementation", "")
if final_implementation and isinstance(final_implementation, str):
    files = extract_code_blocks(final_implementation)
```

**Key Takeaway:** Always validate types before operations, especially when data comes from external sources or APIs.

---

### Documentation for Error Scenarios

**Problem:** When fixing errors, it's easy to forget what was fixed and why, making future debugging harder.

**Solution:** Create a `*_FIXES.md` document that:
- Lists all error scenarios handled
- Explains the fix for each
- Provides testing recommendations
- Documents expected behavior

**Key Takeaway:** Document fixes immediately while context is fresh. Future you (and others) will thank you.

---

### startd8 SDK Dependency Management

**Problem:** The startd8 SDK requires provider packages (like `anthropic`, `openai`) to be installed separately.

**Solution:**
- Check for SDK availability before importing
- Provide clear error messages with installation instructions
- Document required dependencies
- Consider adding dependency checks to setup scripts

**Pattern:**
```python
try:
    from startd8.workflows.builtin.lead_contractor_workflow import LeadContractorWorkflow
except ImportError:
    print("Error: startd8 SDK not found.")
    print("Expected path: /path/to/startd8-sdk/src")
    print("Also ensure provider packages are installed:")
    print("  pip install anthropic openai")
    return error_result
```

**Key Takeaway:** External SDKs often have hidden dependencies. Document them clearly and check for them early.

---

## Template for Future Lessons

Use this format when adding new lessons:

---

### YYYY-MM-DD: [Topic/Feature Name]

**Problem:** [Describe the problem encountered]

**Solution:** [Describe the solution implemented]

**Example/Pattern:** [Code example if applicable]

**Key Takeaway:** [One sentence summary]

---
